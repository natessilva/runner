// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: activities.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countActivities = `-- name: CountActivities :one
SELECT COUNT(*) FROM activities
`

func (q *Queries) CountActivities(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getActivitiesNeedingMetrics = `-- name: GetActivitiesNeedingMetrics :many
SELECT a.id, a.athlete_id, a.name, a.type, a.start_date, a.start_date_local, a.timezone,
    a.distance, a.moving_time, a.elapsed_time, a.total_elevation_gain,
    a.average_speed, a.max_speed, a.average_heartrate, a.max_heartrate,
    a.average_cadence, a.suffer_score, a.has_heartrate, a.streams_synced
FROM activities a
WHERE a.streams_synced = 1
AND NOT EXISTS (SELECT 1 FROM activity_metrics m WHERE m.activity_id = a.id)
ORDER BY a.start_date DESC
`

type GetActivitiesNeedingMetricsRow struct {
	ID                 int64           `db:"id"`
	AthleteID          int64           `db:"athlete_id"`
	Name               string          `db:"name"`
	Type               string          `db:"type"`
	StartDate          string          `db:"start_date"`
	StartDateLocal     string          `db:"start_date_local"`
	Timezone           sql.NullString  `db:"timezone"`
	Distance           float64         `db:"distance"`
	MovingTime         int64           `db:"moving_time"`
	ElapsedTime        int64           `db:"elapsed_time"`
	TotalElevationGain sql.NullFloat64 `db:"total_elevation_gain"`
	AverageSpeed       sql.NullFloat64 `db:"average_speed"`
	MaxSpeed           sql.NullFloat64 `db:"max_speed"`
	AverageHeartrate   sql.NullFloat64 `db:"average_heartrate"`
	MaxHeartrate       sql.NullFloat64 `db:"max_heartrate"`
	AverageCadence     sql.NullFloat64 `db:"average_cadence"`
	SufferScore        sql.NullInt64   `db:"suffer_score"`
	HasHeartrate       int64           `db:"has_heartrate"`
	StreamsSynced      int64           `db:"streams_synced"`
}

func (q *Queries) GetActivitiesNeedingMetrics(ctx context.Context) ([]GetActivitiesNeedingMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivitiesNeedingMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivitiesNeedingMetricsRow{}
	for rows.Next() {
		var i GetActivitiesNeedingMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.AthleteID,
			&i.Name,
			&i.Type,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.AverageCadence,
			&i.SufferScore,
			&i.HasHeartrate,
			&i.StreamsSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivitiesNeedingStreams = `-- name: GetActivitiesNeedingStreams :many
SELECT id, athlete_id, name, type, start_date, start_date_local, timezone,
    distance, moving_time, elapsed_time, total_elevation_gain,
    average_speed, max_speed, average_heartrate, max_heartrate,
    average_cadence, suffer_score, has_heartrate, streams_synced
FROM activities
WHERE streams_synced = 0 AND has_heartrate = 1
ORDER BY start_date DESC
LIMIT ?
`

type GetActivitiesNeedingStreamsRow struct {
	ID                 int64           `db:"id"`
	AthleteID          int64           `db:"athlete_id"`
	Name               string          `db:"name"`
	Type               string          `db:"type"`
	StartDate          string          `db:"start_date"`
	StartDateLocal     string          `db:"start_date_local"`
	Timezone           sql.NullString  `db:"timezone"`
	Distance           float64         `db:"distance"`
	MovingTime         int64           `db:"moving_time"`
	ElapsedTime        int64           `db:"elapsed_time"`
	TotalElevationGain sql.NullFloat64 `db:"total_elevation_gain"`
	AverageSpeed       sql.NullFloat64 `db:"average_speed"`
	MaxSpeed           sql.NullFloat64 `db:"max_speed"`
	AverageHeartrate   sql.NullFloat64 `db:"average_heartrate"`
	MaxHeartrate       sql.NullFloat64 `db:"max_heartrate"`
	AverageCadence     sql.NullFloat64 `db:"average_cadence"`
	SufferScore        sql.NullInt64   `db:"suffer_score"`
	HasHeartrate       int64           `db:"has_heartrate"`
	StreamsSynced      int64           `db:"streams_synced"`
}

func (q *Queries) GetActivitiesNeedingStreams(ctx context.Context, limit int64) ([]GetActivitiesNeedingStreamsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivitiesNeedingStreams, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivitiesNeedingStreamsRow{}
	for rows.Next() {
		var i GetActivitiesNeedingStreamsRow
		if err := rows.Scan(
			&i.ID,
			&i.AthleteID,
			&i.Name,
			&i.Type,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.AverageCadence,
			&i.SufferScore,
			&i.HasHeartrate,
			&i.StreamsSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivity = `-- name: GetActivity :one
SELECT id, athlete_id, name, type, start_date, start_date_local, timezone,
    distance, moving_time, elapsed_time, total_elevation_gain,
    average_speed, max_speed, average_heartrate, max_heartrate,
    average_cadence, suffer_score, has_heartrate, streams_synced
FROM activities
WHERE id = ?
`

type GetActivityRow struct {
	ID                 int64           `db:"id"`
	AthleteID          int64           `db:"athlete_id"`
	Name               string          `db:"name"`
	Type               string          `db:"type"`
	StartDate          string          `db:"start_date"`
	StartDateLocal     string          `db:"start_date_local"`
	Timezone           sql.NullString  `db:"timezone"`
	Distance           float64         `db:"distance"`
	MovingTime         int64           `db:"moving_time"`
	ElapsedTime        int64           `db:"elapsed_time"`
	TotalElevationGain sql.NullFloat64 `db:"total_elevation_gain"`
	AverageSpeed       sql.NullFloat64 `db:"average_speed"`
	MaxSpeed           sql.NullFloat64 `db:"max_speed"`
	AverageHeartrate   sql.NullFloat64 `db:"average_heartrate"`
	MaxHeartrate       sql.NullFloat64 `db:"max_heartrate"`
	AverageCadence     sql.NullFloat64 `db:"average_cadence"`
	SufferScore        sql.NullInt64   `db:"suffer_score"`
	HasHeartrate       int64           `db:"has_heartrate"`
	StreamsSynced      int64           `db:"streams_synced"`
}

func (q *Queries) GetActivity(ctx context.Context, id int64) (GetActivityRow, error) {
	row := q.db.QueryRowContext(ctx, getActivity, id)
	var i GetActivityRow
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.Name,
		&i.Type,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.AverageCadence,
		&i.SufferScore,
		&i.HasHeartrate,
		&i.StreamsSynced,
	)
	return i, err
}

const listActivities = `-- name: ListActivities :many
SELECT id, athlete_id, name, type, start_date, start_date_local, timezone,
    distance, moving_time, elapsed_time, total_elevation_gain,
    average_speed, max_speed, average_heartrate, max_heartrate,
    average_cadence, suffer_score, has_heartrate, streams_synced
FROM activities
ORDER BY start_date DESC
LIMIT ? OFFSET ?
`

type ListActivitiesParams struct {
	Limit  int64 `db:"limit"`
	Offset int64 `db:"offset"`
}

type ListActivitiesRow struct {
	ID                 int64           `db:"id"`
	AthleteID          int64           `db:"athlete_id"`
	Name               string          `db:"name"`
	Type               string          `db:"type"`
	StartDate          string          `db:"start_date"`
	StartDateLocal     string          `db:"start_date_local"`
	Timezone           sql.NullString  `db:"timezone"`
	Distance           float64         `db:"distance"`
	MovingTime         int64           `db:"moving_time"`
	ElapsedTime        int64           `db:"elapsed_time"`
	TotalElevationGain sql.NullFloat64 `db:"total_elevation_gain"`
	AverageSpeed       sql.NullFloat64 `db:"average_speed"`
	MaxSpeed           sql.NullFloat64 `db:"max_speed"`
	AverageHeartrate   sql.NullFloat64 `db:"average_heartrate"`
	MaxHeartrate       sql.NullFloat64 `db:"max_heartrate"`
	AverageCadence     sql.NullFloat64 `db:"average_cadence"`
	SufferScore        sql.NullInt64   `db:"suffer_score"`
	HasHeartrate       int64           `db:"has_heartrate"`
	StreamsSynced      int64           `db:"streams_synced"`
}

func (q *Queries) ListActivities(ctx context.Context, arg ListActivitiesParams) ([]ListActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listActivities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActivitiesRow{}
	for rows.Next() {
		var i ListActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.AthleteID,
			&i.Name,
			&i.Type,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.AverageCadence,
			&i.SufferScore,
			&i.HasHeartrate,
			&i.StreamsSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markStreamsSynced = `-- name: MarkStreamsSynced :execresult
UPDATE activities
SET streams_synced = 1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkStreamsSynced(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, markStreamsSynced, id)
}

const upsertActivity = `-- name: UpsertActivity :exec
INSERT INTO activities (
    id, athlete_id, name, type, start_date, start_date_local, timezone,
    distance, moving_time, elapsed_time, total_elevation_gain,
    average_speed, max_speed, average_heartrate, max_heartrate,
    average_cadence, suffer_score, has_heartrate, streams_synced, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    athlete_id = excluded.athlete_id,
    name = excluded.name,
    type = excluded.type,
    start_date = excluded.start_date,
    start_date_local = excluded.start_date_local,
    timezone = excluded.timezone,
    distance = excluded.distance,
    moving_time = excluded.moving_time,
    elapsed_time = excluded.elapsed_time,
    total_elevation_gain = excluded.total_elevation_gain,
    average_speed = excluded.average_speed,
    max_speed = excluded.max_speed,
    average_heartrate = excluded.average_heartrate,
    max_heartrate = excluded.max_heartrate,
    average_cadence = excluded.average_cadence,
    suffer_score = excluded.suffer_score,
    has_heartrate = excluded.has_heartrate,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertActivityParams struct {
	ID                 int64           `db:"id"`
	AthleteID          int64           `db:"athlete_id"`
	Name               string          `db:"name"`
	Type               string          `db:"type"`
	StartDate          string          `db:"start_date"`
	StartDateLocal     string          `db:"start_date_local"`
	Timezone           sql.NullString  `db:"timezone"`
	Distance           float64         `db:"distance"`
	MovingTime         int64           `db:"moving_time"`
	ElapsedTime        int64           `db:"elapsed_time"`
	TotalElevationGain sql.NullFloat64 `db:"total_elevation_gain"`
	AverageSpeed       sql.NullFloat64 `db:"average_speed"`
	MaxSpeed           sql.NullFloat64 `db:"max_speed"`
	AverageHeartrate   sql.NullFloat64 `db:"average_heartrate"`
	MaxHeartrate       sql.NullFloat64 `db:"max_heartrate"`
	AverageCadence     sql.NullFloat64 `db:"average_cadence"`
	SufferScore        sql.NullInt64   `db:"suffer_score"`
	HasHeartrate       int64           `db:"has_heartrate"`
	StreamsSynced      int64           `db:"streams_synced"`
}

func (q *Queries) UpsertActivity(ctx context.Context, arg UpsertActivityParams) error {
	_, err := q.db.ExecContext(ctx, upsertActivity,
		arg.ID,
		arg.AthleteID,
		arg.Name,
		arg.Type,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Timezone,
		arg.Distance,
		arg.MovingTime,
		arg.ElapsedTime,
		arg.TotalElevationGain,
		arg.AverageSpeed,
		arg.MaxSpeed,
		arg.AverageHeartrate,
		arg.MaxHeartrate,
		arg.AverageCadence,
		arg.SufferScore,
		arg.HasHeartrate,
		arg.StreamsSynced,
	)
	return err
}
